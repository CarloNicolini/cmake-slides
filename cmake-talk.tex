\documentclass[10pt] {beamer}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usetheme {Air}
\usepackage {thumbpdf}
\usepackage {wasysym}
\usepackage {ucs}
\beamertemplatenavigationsymbolsempty
%\usepackage {pgf,pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
\usepackage {verbatim}
\pdfinfo
{
    /Title       (Build facili con CMake)
    /Creator     (TeX)
    /Author      (Carlo Nicolini)
}


\title {Build facili con CMake}
\subtitle {Il sistema di build -definitivo-}
\author {Carlo Nicolini}
\date {\today}

\begin {document}

\frame {\titlepage}

\begin {frame}
\frametitle {Outline}
\tableofcontents[section=1,hidesubsections]
\end {frame}

\AtBeginSection[]
{
    \frame<handout:0>
    {
        \frametitle{Outline}
        \tableofcontents[currentsection,hideallsubsections]
    }
}

\AtBeginSubsection[]
{
    \frame<handout:0>
    {
        \frametitle{Outline}
        \tableofcontents[sectionstyle=show/hide,subsectionstyle=show/shaded/hide]
    }
}

\newcommand<> {\highlighton} [1] {%
\alt#2{\structure{#1}}{{#1}}
                                 }
\newcommand {\icon} [1] {\pgfimage[height=1em]{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% Content starts here %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduzione}
\begin{frame}
\frametitle{Motivazioni}
Un sistema di build per C/C++ ci permette di essere più efficienti, produttivi e chiari.
Vogliamo un sistema di build che ci permetta
\begin{itemize}
\item<1-> Portabilità su molti O.S.
\item<2-> Gestione di molti tipi di build diversa
\item<3-> Supporto a librerie esterne
\item<4-> Facilità di mantenimento di un progetto
\item<5-> Chiarezza ed intuitività, \textbf{velocità} di build
\item<6-> Build parallele
\item<7-> Miglior rapporto con chi userà il nostro codice
\item<8-> Packing, unit testing, profiling e debugging ALL-IN-ONE
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Il passato}
Un sistema di build si occupa di generare eseguibili/librerie partendo dai sorgenti \footnote{\url{http://www.cs.virginia.edu/~dww4s/articles/build_systems.html}}
\begin{figure}[htb]
 \centering
 \includegraphics[width=0.6\textwidth]{hello_digraph.png}
\end{figure}
Problema delle dipendenze è un problema su grafo DAG. Il grafo direzionato informa il sistema di build cosa ricompilare se un file cambia. Se \texttt{hello.c} cambia allora tutti i nodi da lì in poi devono essere ricompilati
Un buon sistema di build affronta e risolve i seguenti problemi:
\begin{itemize}
\item Soluzione delle dipendenze 
\item Build parallele
\item Analisi dei punti di articolazione (limite al parallelismo)
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{In passato}
In passato sono apparsi tanti sistemi, ognuno con i suoi pro e contro. Dimentichiamo la compilazione manuale (anni 70)
\begin{verbatim}
 gcc -c mylibrary.cpp mylibrary.h -o mylibrary.o
\end{verbatim}
e passiamo ai sistemi di build automatici:

\begin{itemize}
\item<1-> Scons \textit{basato su Python, cross-platform}
\item<2-> Autotools \textit{ molto usato, sintassi complicata (Autohell), solo Unix }
\item<3-> Jam \textit{ (cross-platform,cross-language), buggy, poco automatico}\footnote{\url{http://en.wikipedia.org/wiki/Perforce_Jam}}
\item<4-> Waf \textit{ python un singolo file da redistribuire \footnote{\url{http://docs.waf.googlecode.com/git/book_17/waf.pdf}}}
\item<5-> eccetera...
\end{itemize}
In genere, poco supporto, piccola comunità, tanti bachi.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{CMake}
Un sistema di build moderno gestisce building, testing e packaging tutto insieme, scritto in C++, supporta progetti C/C++\footnote{\url{www.cmake.org}}.
\begin{itemize}
		\item<1-> Sistema di meta-make, multiprogetto (targets)
		\item<2-> Supporto a tanti ambienti di sviluppo (IDE) tramite \emph{generatori}\footnote{\url{http://www.cmake.org/cmake/help/v2.8.8/cmake.html\#section\_Generators}}: 

Kdevelop3, Eclipse, XCode, Code::Blocks ,VisualStudio, Makefiles (Unix, NMake, Borland, MinGW, Cygwin)

		\item<3-> Cross plattform (veramente).
		\item<4-> Dipendenze soddisfatte sempre (veramente).
		\item<5-> Un linguaggio di scripting che da libertà (vera).
		\begin{itemize}
			\item<6-> \texttt{\#define } a compile-time tramite variabili scriptabili.
			\item<7-> Supporto menu Gnome, icone e creazione setup personalizzati.
			\item<8-> Centinaia di librerie esterne supportate.
		\end{itemize}
		\item<9-> Build multiprocessore
		\item<10-> \textbf{Out-of-source} builds: fare una build senza ``sporcare'' la codebase
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}
%\frametitle{CMake workflow}
%	\begin{itemize}
%		\item CMakeLists.txt
%		\item Makefile/.vcproj/ .xcode
%		\item .obj/.o
%		\item .exe/ .dll/ .lib/ .dylib
%	\end{itemize}
%\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{CMake tree e primi passi}
Supponiamo di avere questo tree:

\begin{itemize}
\item<1-> \textbf{src}
\begin{itemize}
	\item myapp.cpp
	\item myapp.h
	\item CMakeLists.txt
\end{itemize}
\item<2-> \textbf{build}
\item<3-> CMakeLists.txt
\end{itemize}

Si fa la build con:
\begin{verbatim}
 cmake .
 make
\end{verbatim}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
	\frametitle{Linguaggio - Variabili}
	\begin{itemize}
		\item Non serve dichiararle (stringa vuota se non esistono)
		\item Atipizzate
		\item SET crea e modifica variabili
		\item SET si affianca a LIST
		\item SEPARATE\_ARGUMENTS spezza argomenti separati da spazio in una LIST
		\item In Cmake 2.4: globali (name clashing problems)  In Cmake 2.6: scoped
		\item CMake corrente 2.9
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\frametitle{Linguaggio - Variabili}
	\begin{itemize}
		\item Non serve dichiararle (stringa vuota se non esistono)
		\item Atipizzate
		\item SET crea e modifica variabili
		\item SET si affianca a LIST
		\item SEPARATE\_ARGUMENTS spezza argomenti separati da spazio in una LIST
		\item In Cmake 2.4: globali (name clashing problems)  In Cmake 2.6: scoped
		\item CMake corrente 2.9
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
	\frametitle{Sintassi}
\begin{itemize}
 \item Costrutto condizionale IF
	\begin{verbatim}
	IF ( expression )
	...
	ELSE ( expression )
	...
	ENDIF ( expression )
	\end{verbatim}
\item Costrutto FOREACH ( comodo per liste)
	\begin{verbatim}
	FOREACH ( loopvariable )
	...
	ENDFOREACH ( loopvariable )
	\end{verbatim}
\item Ciclo WHILE
	\begin{verbatim}
	WHILE ( condition )
	...
	ENDWHILE ( condition )
	\end{verbatim}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Esempio di foreach e wildcards su files}
\begin{verbatim}
file(GLOB mytestfiles "test*.cpp")
foreach(testfile ${mytestfiles})
  message(STATUS "This is a test file ${testfile}")
endforeach(testfile ${mytestfiles })
\end{verbatim}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{switch condizionali di sistema}
\begin{verbatim}
IF ( MSVC )
ENDIF ( MSVC )

IF (WIN32)
ENDIF (WIN32)
 		
IF ( UNIX )
ENDIF (UNIX)
 		
IF (APPLE)
ENDIF (APPLE)
\end{verbatim}
\begin{itemize}
\item Tutte le variabili sono scoped nel singolo CMakeLists.txt
\item Non esiste un costrutto \textbf{switch}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{ Espressioni regolari}
Complicate ma possibili
\begin{verbatim}
STRING( REGEX MATCH ... )
STRING (REGEX MATCHALL ... )
STRING(REGEX REPLACE ... )
\end{verbatim}
Esempio:
\begin{verbatim}
SET(test "hello world ! catch: me if you can")
STRING(REGEX REPLACE ".*catch: ([^ ]+).*" "\\1" result "${test}" )
MESSAGE(STATUS "result= ${result}")
\end{verbatim}
stampa a stdout:
\begin{verbatim}
  -- result= me
\end{verbatim}
(il ``--'' è stampato ad ogni riga di default)
\end{frame}




\begin{frame}[fragile]
 \frametitle{ Espressioni regolari }
How to convert a semicolon separated list to a whitespace separated string?
\begin{verbatim}
set(foo abc.c abc.b abc.a)

foreach(arg ${foo})
    set(bar "${bar} ${arg}")
endforeach(arg ${foo})
 
message("foo: ${foo}")
message("bar: ${bar}")
\end{verbatim}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Compatibilità con versioni precedenti}
\begin{itemize}
\item Molto importante impostare la compatibilita con le versioni precedenti, cambi di sintassi e bug-fix
\item Mantenere sempre CMake all'ultima versione (attuale 2.8.10)
\item Variabile di sistema apposita
\end{itemize}
\begin{verbatim}
 CMAKE_MINIMUM_REQUIRED(VERSION 2.6.0 FATAL_ERROR)
\end{verbatim}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Cmake cache}
\begin{itemize}
\item CMake salva le variabili non variate in un file CMakeCache.txt
\item Veloce su Unix, lento su Windows (MSVC)
\item Utile ripulire la cache
\end{itemize}

\begin{itemize}
\item \texttt{rm CMakeCache.txt}, oppure
\item Cancellare manualmente il file \texttt{CMakeCache.txt}
\item Rigenerare il progetto
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Gestione di Debug e Release}
\begin{itemize}
\item Una variabile definisce il tipo di build
\item
\begin{verbatim}
SET(CMAKE_BUILD_TYPE XXX)
\end{verbatim}
    \begin{itemize}
    \item Debug
    \item Release
    \item RelWithDebInfo
    \item MinSizeRel
    \item Profile
    \end{itemize}
\item oppure da linea di comando:
\begin{verbatim}
cmake -DCMAKE_BUILD_TYPE=Debug .
\end{verbatim}

\item \texttt{Debug} $\rightarrow$ gdb+valgrind, grosse dimensioni
\item Si rilascia il pacchetto sempre in \texttt{Release}
\item \texttt{Profile} utile quando accoppiata con gprof/KCacheGrind
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
 \frametitle{Versionamento compile-time}
\begin{itemize}
 \item Utilizzare il modulo \texttt{UseSubversion} \url{http://bit.ly/WjwiRP} (ripulire il repo prima)
\item Vengono definite alcune variabili utili:
\begin{itemize}
\item 

\begin{small}
\begin{verbatim}
SUBVERSION_REPO_REVISION
SUBVERSION_REPO_LAST_CHANGED_DATE
etcetera
\end{verbatim}
\end{small}
\item Passabili al compilatore come flags:
\begin{small}
\begin{verbatim}
ADD_DEFINITIONS(-DREV_NUMBER=
"${SUBVERSION_REPO_REVISION}")
\end{verbatim}
\end{small}
\end{itemize}
\item Nel codice C/C++ quindi:
\begin{verbatim}
int revision=REV_NUMBER;
printf("La versione corrente è %d\n", revision);
\end{verbatim}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
 \frametitle{Generare la documentazione}
Aggiungere un target \texttt{doc} ed usare \texttt{FindDoxygen.cmake}
\begin{footnotesize}
\begin{verbatim}
# Aggiunge un target al Makefile per generare 
# la doc usando Doxygen
find_package(Doxygen)
if(DOXYGEN_FOUND)
configure_file(${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile 
    ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile @ONLY)
add_custom_target(doc
${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile
WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
COMMENT "Generating API documentation with Doxygen" 
    VERBATIM )
endif(DOXYGEN_FOUND)
\end{verbatim}
\end{footnotesize}
\footnote{\url{http://bit.ly/9eel8b}}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Esempi e tutorial}

\begin{frame}[fragile]
\frametitle{HelloWorld eseguibile}
\begin{verbatim}
#Creiamo il nome del progetto
PROJECT( helloworld )
# Impostiamo la variabile hello_SRCS a contenere la hello.cpp
SET( hello\_SRCS hello.cpp )
# Crea l'eseguibile di nome hello dal file contenuto nella variabile hello\_SRCS
ADD\_EXECUTABLE( hello \$\{hello\_SRCS\} )
\end{verbatim}

\begin{itemize}
	\item Tutte le variabili sono \textbf{stringhe}
	\item Le variabili si dereferenziano bash-style 
	  \begin{verbatim}
	  ${NOMEVARIABILE} 
	  \end{verbatim}
	\item Le variabili si impostano con SET
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
	\frametitle{Creazione libreria statica .a}
\begin{small}
\#Creiamo il nome del progetto

\textbf{PROJECT( mylibrary )}

\# Impostiamo la variabile mylibrary\_SRCS a contenere tutti i file che definiscono la libreria

\textbf{SET( mylibrary\_SRCS Foo.cpp Bar.cpp Qux.cpp)}

\# Crea una libreria STATICA (di default in CMake) a partire dai sorgenti

\# in Linux con gcc genera un file \emph{lib}myLibrary.a

\textbf{ADD\_LIBRARY( myLibrary \$\{mylibrary\_SRCS\} )}

\# Oppure crea una libreria SHARED (o DINAMICA in Windows) a partire dai sorgenti

\# in Linux con gcc genera un file \emph{lib}myLibrary.so
\textbf{ADD\_LIBRARY( myLibrary SHARED \$\{mylibrary\_SRCS\} )}
\end{small}
\end{frame}


\begin{frame}[fragile]
 \frametitle{Generazione grafo delle dipendenze}
CMake supporta la generazione visual del grafo delle dipendenze fra files, sfruttando il pacchetto di graph-drawing graphviz
\begin{verbatim}
cmake --graphviz=nomefile.dot .

\end{verbatim}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Supporto a librerie esterne}
\begin{frame}[fragile]
 \frametitle{Supporto a OpenMP}
\begin{footnotesize}
\begin{verbatim}
include(FindOpenMP)
if(OPENMP_FOUND)
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} 
         ${OpenMP_CXX_FLAGS}")
   set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} 
         ${OpenMP_EXE_LINKER_FLAGS}")
endif()
\end{verbatim}
\end{footnotesize}
\begin{itemize}
 \item Sceglie il flag appropriato del compilatore (g++ -fopenmp, icc -openmp, MSVC /OMP )
 \item Problemi con \texttt{vcompd.dll}, modificare il file manifest con MSVC9 (2008)\footnote{\url{http://kitware.com/blog/home/post/4}}
\item \url{http://public.kitware.com/Bug/view.php?id=12964}
\end{itemize}

\end{frame}


\begin{frame}[fragile]
\frametitle{CMake e Qt}
CMake interagisce molto bene con Qt (e viceversa)
\begin{footnotesize}
\begin{verbatim}
set(QT_MIN_VERSION "4.6.0")
set(QT_USE_QTMAIN TRUE)
set(QT_USE_OPENGL TRUE)
find_package(Qt4 4.6.0 COMPONENTS QtGui QtCore 
	    QtOpenGL REQUIRED )
INCLUDE(${QT_USE_FILE})
\end{verbatim}
\end{footnotesize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
 \frametitle{CMake e Qt}
\begin{footnotesize}
\begin{verbatim}
set(MyApp_HDR  Foo.h)
# MyApp source files
set(MyApp_SRC main.cpp mainwindow.cpp Foo.cpp )
# User interface files
set(MyApp_FORMS mainwindow.ui ) 
set(MyApp_RESOURCES "myapp_images.qrc")

QT4_ADD_RESOURCES( MyApp_RESOURCES_SOURCES 
    ${MyApp_RESOURCES} )
QT4_WRAP_UI( MyApp_FORMS_HEADERS ${MyApp_FORMS} )
QT4_WRAP_CPP( MyApp_HEADERS_MOC ${MyApp_HDR} )

add_executable(MyApp WIN32 ${MyApp_SRC} ${MyApp_HDR}
    ${MyApp_HEADERS_MOC} ${MyApp_RESOURCES_SOURCES}
    ${MyApp_FORMS_HEADERS} ${MyApp_RCS})
\end{verbatim}
\end{footnotesize}
\end{frame}

\begin{frame}[fragile]
 \frametitle{Semplice progettino con Qt}
\begin{verbatim}
 PROJECT( pfrac )
FIND_PACKAGE( Qt4 REQUIRED )
INCLUDE( ${QT_USE_FILE} )
SET( pfrac_SRCS main.cpp client.h client.cpp )
SET( pfrac_MOC_HEADERS client.h )
QT4_ADD_RESOURCES( pfrac_SRCS 
     ${PROJECT_SOURCE_DIR}/pfrac.qrc )
QT4_WRAP_CPP( pfrac_MOC_SRCS 
     ${pfrac_MOC_HEADERS} )
ADD_EXECUTABLE( pfrac ${pfrac_SRCS} $
{pfrac_MOC_SRCS} 
TARGET_LINK_LIBRARIES( pfrac ${QT_LIBRARIES} )
\end{verbatim}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Boost}
Boost è una libreria estensione del C++:
\begin{itemize}
\item ``...one of the most highly regarded and expertly designed C++ library projects in the world.''
— Herb Sutter and Andrei Alexandrescu, C++ Coding Standards
\item ``Item 55: Familiarize yourself with Boost.``
— Scott Meyers, Effective C++, 3rd Ed.
\item ``The obvious solution for most programmers is to use a library that provides an elegant and efficient platform independent to needed services. Examples are BOOST...''
— Bjarne Stroustrup, Abstraction, libraries, and efficiency in C++
\end{itemize}
Boost contiene supporto headers-only e anche librerie bimap, containers generici, interfacce IO, socket, \textbf{threading}.
\end{frame}

\begin{frame}[fragile]
 \frametitle{CMake + Boost}
Nel CMakeLists.txt di base
\begin{verbatim}
# Set the needed boost libraries 
set(BOOST_LIBS thread date_time system program_options 
  filesystem regex serialization iostreams)
set(Boost_USE_STATIC_LIBS        ON)
set(Boost_USE_MULTITHREADED      ON)
set(Boost_USE_STATIC_RUNTIME    OFF)

find_package(Boost COMPONENTS ${BOOST_LIBS} REQUIRED)
include_directories(${Boost_INCLUDE_DIR})
find_package(Threads REQUIRED)
\end{verbatim}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
 \frametitle{CMake + Boost}
Linkare una libreria a Boost
\begin{verbatim}
add_library(FooBar Foo.cpp Bar.cpp)
target_link_libraries(FooBar 
  ${BOOST_LIBRARIES})
\end{verbatim}
Linkare un eseguibile a Boost:
\begin{verbatim}
add_executable(myApplication myApplication.cpp 
    Foo.cpp Bar.cpp)
target_link_libraries(myApplication(myApplication 
    ${BOOST_LIBRARIES})
\end{verbatim}
Viene \textbf{automagicamente} selezionata la versione della libreria corretta:
\begin{itemize}
\item \textbf{build statica multithread} \verb_/usr/lib/libboost_\verb_thread-mt.a_
\item \textbf{build dinamica non-multithread} \verb_/usr/lib/libboost_\verb_thread.so_
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
 \frametitle{CMake + OpenGL}
Esistono diversi modi di supportare OpenGL con CMake, sono tutti cross-platform
\begin{itemize}
 \item FindOpenGL.cmake
 \item FindGlut.cmake
\end{itemize}

Su Linux è molto facile (previa installazione di GLU/GLUT/FreeGLUT
\begin{verbatim}
find_package(OpenGL REQUIRED)
include_directories(${OPENGL_INCLUDE_DIR})
find_package(GLUT REQUIRED)
set(GL_LIBS ${OPENGL_LIBRARIES} ${GLUT_LIBRARIES})
...
target_link_libraries(myApp ${GL_LIBS})
\end{verbatim}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
 \frametitle{Chiamate al sistema}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
 \frametitle{Chiamate al sistema - Esempio}
\begin{verbatim}
include( UseCython )
add_custom_target( ReplicatePythonSourceTree ALL ${CMAKE_COMMAND} -P
  ${CMAKE_CURRENT_SOURCE_DIR}/cmake/ReplicatePythonSourceTree.cmake
  ${CMAKE_CURRENT_BINARY_DIR}
  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} )
\end{verbatim}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Creazione pacchi con CPack}
\begin{frame}
\frametitle{Highlighting}
CPack è il progetto cugino di CMake con cui è strettamente integrato e permette di creare pacchi:
\begin{itemize}
\item Linux generici ( .sh, .tgz )
\item Distro-based ( .deb, .rpm, )
\item OSX (creazione .app o dischi .dmg )
\item Windows (creazione setup.exe grazie a NSIS installer e 7Zip )
\end{itemize}
\begin{itemize}
\item Pacchi architettura-specifici
\item Cross compilazione!
\end{itemize}

\end{frame}


\newcommand{\putlink} [1]{%
                          \pgfsetlinewidth{1.4pt}%
                          \pgfsetendarrow{\pgfarrowtriangle{4pt}}%
\pgfline{\pgfxy(1,1)}{\pgfxy(#1,1)}
                         }

\begin{frame}
\frametitle{Risorse online}
\begin{thebibliography}{10}

\beamertemplatearticlebibitems

\bibitem{CMake mailing list}
Mailing list ufficiale degli utenti di CMake
\newblock{\url{http://www.cmake.org/mailman/listinfo/cmake}}

               \bibitem{stackoverflow}
               Sito di domande e risposte, frequentato da molti utenti di CMake
               \newblock{\url{www.stackoverflow.com}}

               \bibitem{Cmake tutorial}
               CMake tutorial online
               \newblock{\url{http://www.cmake.org/cmake/help/cmake_tutorial.html}}

                              \bibitem{Mastering CMake}
                              Il libro ufficiale, insostituibile (in biblioteca di ingegneria a Mesiano )
                              \newblock{\url{http://www.kitware.com/products/books/CMakeBook.html}}

                                        \bibitem{kdeslides}
                                        Slides fatte con il tema beamer offerto da KDE
                                        \newblock {\tt http://www.kde.org/kdeslides/}

                                                \end{thebibliography}
                                                \end{frame}

\frame{
    \vspace{2cm}
    {\huge Domande ?}

    \vspace{3cm}
    \begin{flushright}
    Carlo Nicolini

    \structure{\footnotesize{nicolini.carlo@gmail.com}}
    \end{flushright}
}

\end{document}
